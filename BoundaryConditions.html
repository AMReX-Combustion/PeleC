<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Boundary Conditions &mdash; PeleC 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Geometry treatment in PeleC" href="geometry/EB.html" />
    <link rel="prev" title="Testing and Verification" href="Testing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PeleC
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Equations.html">Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Algorithms.html">Numerical Treatment and Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Boundary Conditions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#isothermal-walls">Isothermal Walls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#navier-stokes-characteristic-boundary-conditions">Navier-Stokes Characteristic Boundary Conditions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="geometry/EB.html">Geometry treatment in PeleC</a></li>
<li class="toctree-l1"><a class="reference internal" href="LES.html">LES and Hybrid LES/DNS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="VandV.html">Correctness - Verification and Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="PelePhysics.html">PelePhysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="BoxlibBits.html">Development Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PeleC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Boundary Conditions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/BoundaryConditions.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="boundary-conditions">
<span id="bcs"></span><h1>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Link to this heading">ÔÉÅ</a></h1>
<p>PeleC manages boundary conditions in a form consistent with many AMReX codes. Ghost cell data are updated over an AMR level during a <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> operation and fluxes are then computed over the entire box without specifically recognizing boundary cells. A generic boundary filler function fills standard boundary condition types that do not require user input, including:</p>
<ul class="simple">
<li><p><em>Interior</em> - Copy-in-intersect in index space (same as periodic boundary conditions). Periodic boundaries are set in the PeleC inputs file</p></li>
<li><p><em>Symmetry</em> - All conserved quantities and the tangential momentum component are reflected from interior cells without
sign change (REFLECT_EVEN) while the normal component is reflected with a sign change (REFLECT_ODD)</p></li>
<li><p><em>NoSlipWall</em> - REFLECT_EVEN is applied to all conserved quantities except for both tangential and normal momentum components which are updated
using REFLECT_ODD</p></li>
<li><p><em>SlipWall</em>  - SlipWall is identical to Symmetry</p></li>
<li><p><em>FOExtrap</em> - First-order extrapolation: the value in the ghost-cells are a copy of the last interior cell.</p></li>
</ul>
<p>More complex boundary conditions require user input that is prescribed explicitly. Boundaries identified as <code class="docutils literal notranslate"><span class="pre">UserBC</span></code> or <code class="docutils literal notranslate"><span class="pre">Hard</span></code> in the inputs will be tagged as <code class="docutils literal notranslate"><span class="pre">EXT_DIR</span></code> in <code class="docutils literal notranslate"><span class="pre">pc_hypfill</span></code>.  Users will then fill the boundary values, by calling the helper function, <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code>. The <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> function fills an exterior (ghost) cell based on the value of the outermost interior cell. Its arguments include a problem-specific data structure, the location, direction, and orientation of the boundary being filled, and potentially fluctuating turbulent velocities from the <a class="reference external" href="https://amrex-combustion.github.io/PelePhysics/Utility.html#turbulent-inflows">TurbInflow</a> utility in PelePhysics. This gives the user flexibility to specify a variety of boundary conditions, including faces that contain both walls and inflow regions. Note that the external state <code class="docutils literal notranslate"><span class="pre">s_ext</span></code> is prepopulated with the same values as are used for the <code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code> condition, so the default if the <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> function does nothing is to specify a <code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To ensure conservation, when Godunov schemes are used the order of accuracy is reduced at boundaries specified using <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code>; PLM is used and the predictor step is omitted when computing fluxes through these boundaries. This does not affect any other boundary types or simulations using MOL.</p>
</div>
<p>Special care should be taken when prescribing subsonic <code class="docutils literal notranslate"><span class="pre">Inflow</span></code> or an <code class="docutils literal notranslate"><span class="pre">Outflow</span></code> boundary conditions. It might be tempting to directly impose target values in the boundary filler function (for <code class="docutils literal notranslate"><span class="pre">Inflow</span></code>), or to perform a simple extrapolation (for <code class="docutils literal notranslate"><span class="pre">Outflow</span></code>).  However, this approach would fail to correctly respect the flow of information along solution characteristics - the system would be ill-posed and would lead to unphysical behavior. In particular, at a subsonic inflow boundary, at a subsonic inlet there is one outgoing characteristic, so one flow variable must be specified using information from inside the domain. Similarly, there is one incoming characteristic at outflow boundaries. The NSCBC method, described below, is the preferred method to account for this, but has not been ported to the all C++ version of PeleC. In the meantime, the recommended strategy for subsonic inflow and outflow boundaries for confined geometries such as nozzles and combustors is as follows:</p>
<ul class="simple">
<li><p>Subsonic Inflows: Specify the desired temperature, velocity, and composition (if relevant) in the ghost cells. Take the pressure from the domain interior. Based on these values, compute the density, internal energy, and total energy for the ghost cells.</p></li>
<li><p>Subsonic Outflows: Specify the desired outlet pressure and extrapolate the other flow quantities. In particular, we recommend following the simple characteristic-based extrapolation proposed by Whitfield and Janus (<a class="reference external" href="https://arc.aiaa.org/doi/abs/10.2514/6.1984-1552">Three-Dimensional Unsteady Euler Equations Solution Using Flux Vector Splitting. AIAA Paper 84-1552, 1984.</a>) and described in Ch. 8 of Blazek‚Äôs textbook (<a class="reference external" href="https://www.sciencedirect.com/book/9780080445069/computational-fluid-dynamics-principles-and-applications">Computational Fluid Dunamics - Principles and Applications</a>). Implementations of this method can be found in the <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> function in <code class="docutils literal notranslate"><span class="pre">prob.H</span></code> for various test cases, including EB-C10 and EB-ConvergingNozzle.</p></li>
</ul>
<p>A detailed analysis comparing various boundary condition strategies and demonstrating their implementation is available for the <a class="reference internal" href="ebverification/ConvergingNozzle/README.html#eb-convergingnozzle"><span class="std std-ref">Converging Nozzle Case</span></a> case.</p>
<section id="isothermal-walls">
<h2>Isothermal Walls<a class="headerlink" href="#isothermal-walls" title="Link to this heading">ÔÉÅ</a></h2>
<p>By default, the boundaries specified as <code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code> and <code class="docutils literal notranslate"><span class="pre">SlipWall</span></code> are adiabatic. For isothermal wall boundaries, energy fluxes through the isothermal wall are computed separately, rather than being based on values populated in the ghost cells. To activate computation of isothermal wallfluxes, use the input file option <code class="docutils literal notranslate"><span class="pre">pelec.do_isothermal_walls</span> <span class="pre">=</span> <span class="pre">1</span></code> and then specify the desired wall temperatures using, for example, <code class="docutils literal notranslate"><span class="pre">pelec.domlo_wall_temp</span> <span class="pre">=</span> <span class="pre">-1</span> <span class="pre">-1</span> <span class="pre">300.0</span></code> and <code class="docutils literal notranslate"><span class="pre">pelec.domhi_isothermal_temp</span> <span class="pre">=</span> <span class="pre">-1</span> <span class="pre">-1</span> <span class="pre">400.0</span></code>, which would leave the x and y boundaries as adiabatic, make the lower z boundary isothermal at 300 K, and make the upper z boundary isothermal at 400 K. Any boundary with a negative (or zero) value for the specified temperature is treated as adiabatic; boundaries that are not <code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code>, <code class="docutils literal notranslate"><span class="pre">SlipWall</span></code>, <code class="docutils literal notranslate"><span class="pre">UserBC</span></code>, or <code class="docutils literal notranslate"><span class="pre">Hard</span></code> must always have a negative value specified.</p>
</section>
<section id="navier-stokes-characteristic-boundary-conditions">
<h2>Navier-Stokes Characteristic Boundary Conditions<a class="headerlink" href="#navier-stokes-characteristic-boundary-conditions" title="Link to this heading">ÔÉÅ</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This following is currently deprecated as the GS-NSCBC boundary condition has not been ported from Fortran to C++.</p>
</div>
<p>A well-known approach to the subsonic problem is the Navier-Stokes Characteristic Boundary Conditions
(NSCBC) strategy, and is described in the paper <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/0021999192900462">Poinsot and Lele (1992) JCP</a>.  In the method, the hyperbolic structure is
decomposed to identify incoming and outgoing waves, given a statement of the ‚Äúexternal‚Äù state outside the domain, and
then to construct a model that gives ‚Äúdesired‚Äù behavior at the interface.  One issue with direct application of
the NSCBC treatment in PeleC is that it is formulated to impose boundary fluxes directly. In PeleC however, the
Godunov approach that is implemented makes use of boundary data specified via grow cell values, and reconstructs fluxes at faces when required. Thus, the NSCBC strategy has been reformulated to provide the grow cell data required in PeleC. The strategy,
the Ghost-Cells Navier-Stokes Boundary Conditions (GC-NSCBC) method, is described in <a class="reference external" href="https://ccse.lbl.gov/people/motheau/Manuscripts_website/2017_AIAA_CFD_Motheau.pdf">Motheau et al. (2017) AIAA Journal</a>.</p>
<p>For the characteristics-based boundary condition implementation, the solution is rewritten in terms of one-dimensional hyperbolic wave propagation. The waves leaving the domain are computed numerically, while the waves entering into the domain are provided by a model that is based on a ‚Äútarget state‚Äù. With the help of numerical relaxation parameters, the contribution of entering waves can be controlled to afford some freedom at the boundary to ‚Äúpush‚Äù toward a target state while also allowing acoustic waves to leave the domain.  The approach allows some control to minimize the effects of reflected waves, which would otherwise result from the ‚Äúhard‚Äù imposition of the external conditions. Description of the relevant theory is beyond the scope of this documentation (see the paper <a class="reference external" href="https://ccse.lbl.gov/people/motheau/Manuscripts_website/2017_AIAA_CFD_Motheau.pdf">Motheau et al. (2017) AIAA Journal</a>, which also contains examples demonstrating why imposing directly target values in ghost-cells
does not work as expected, and why the NSCBC theory helps to get a more ‚Äúdesirable‚Äù solution).</p>
<p>In order to understand the impact of the GC-NSCBC treatment, we give an example that imposes ‚Äúhard‚Äù values in the ghost-cells to represent external conditions, and uses first-order extrapolation at the outflow boundary.
A precomputed 1D flame profile is interpolated onto a uniform PeleC grid. Because the solution has to adapt to the new grid and to the PeleC numerical discretization, it creates an unphysical acoustic bump that moves through the domain as an acoustic disturbance.  With ‚Äúhard‚Äù boundary conditions, this disturbance is reflected from the outflow boundary back into the domain, and interacts with the flame upstream.  A steady solution to this system would require the propagation of this wave back and forth until numerical diffusion eventually reduces its magnitude below some threshold. With the GC-NSCBC boundary treatment, the acoustic wave simply leaves the computational domain.  Often times, the latter is the desired behavior of the code.</p>
<blockquote>
<div><figure class="align-center" style="width: 40%">
<img alt="_images/1D_PMF_NO_NSCBC.gif" src="_images/1D_PMF_NO_NSCBC.gif" />
</figure>
</div></blockquote>
<p>No GC-NSCBC treatment, hard values set at the left boundary for the inflow, and first order extrapolation in the right boundary to mimic an outflow. The unphysical reflections of the acoustic wave at boundary can be clearly seen.</p>
<figure class="align-center" style="width: 40%">
<img alt="_images/1D_PMF_WITH_NSCBC.gif" src="_images/1D_PMF_WITH_NSCBC.gif" />
</figure>
<p>With the GC-NSCBC, the spurious acoustic wave simply leaves the domain with no unphysical reflection.</p>
<p>In PeleC, the subroutine <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> is used to provide the target state for the GC-NSCBC treatment as well as the numerical parameters used by the GC-NSCBC method to efficiently ‚Äúdamp‚Äù the reflected waves. Note the signature and the content of the <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code> routine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>subroutine bcnormal(x,u_int,u_ext,dir,sgn,time,bc_type,bc_params,bc_target)

...

integer, optional, intent(out) :: bc_type
double precision, optional, intent(out) :: bc_params(6)
double precision, optional, intent(out) :: bc_target(5)

...

double precision :: relax_U, relax_V, relax_W, relax_T, beta, sigma_out
integer :: flag_nscbc, which_bc_type

flag_nscbc = 0

! When optional arguments are present, GC-NSCBC is activated
! Generic values are auto-filled for numerical parameters,
! but should be set by the user for each BC
! Note that in the impose_NSCBC_xD.f90 routine, not all parameters are used in same time
if (present(bc_type).and.present(bc_params).and.present(bc_target)) then
  flag_nscbc = 1
  relax_U = 0.5d0 ! For inflow only, relax parameter for x_velocity
  relax_V = 0.5d0 ! For inflow only, relax parameter for y_velocity
  relax_W = 0.5d0 ! For inflow only, relax parameter for z_velocity
  relax_T = -0.2d0 ! For inflow only, relax parameter for temperature
  beta = 1.0d0  ! Control the contribution of transverse terms, here they will be discarded
  sigma_out = -0.6d0 ! For outflow only, relax parameter. A negative value means that the local Mach number will be used
  which_bc_type = Interior ! This is to ensure that nothing will be done if the user don&#39;t set anything
endif
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">bc_type</span></code>, <code class="docutils literal notranslate"><span class="pre">bc_params</span></code> and <code class="docutils literal notranslate"><span class="pre">bc_target</span></code> parameters are present, the routine is likely being called from <code class="docutils literal notranslate"><span class="pre">impose_NSCBC_(dir)d.F90</span></code>. In this case the flag <code class="docutils literal notranslate"><span class="pre">flag_nscbc</span></code> is activated to fill optional arrays with the requisite data. Note however that the <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> operation called in the AMReX framework also calls <code class="docutils literal notranslate"><span class="pre">pc_hypfill</span></code>, which then also calls <code class="docutils literal notranslate"><span class="pre">bcnormal</span></code>.  In this case, the GC-NSCBC parameters are not directly relevant. In order to make <code class="docutils literal notranslate"><span class="pre">bc_normal</span></code> sufficiently generic for both purposes, only the target state is returned to <code class="docutils literal notranslate"><span class="pre">pc_hypfill</span></code> and the parameters associated to the GC-NSCBC method are ignored. By default, the GC-NSCBC method is activated for all subsonic flow boundaries. It can be turned off by setting the flags <code class="docutils literal notranslate"><span class="pre">nscbc_adv</span></code> and <code class="docutils literal notranslate"><span class="pre">nscbc_diff</span></code> to zero. In that case, the ghost-cells will be filled directly with the target state (although, as mentioned, this will likely lead to undesired behavior in the solution!).</p>
<p>The use of <code class="docutils literal notranslate"><span class="pre">bc_type</span></code>, <code class="docutils literal notranslate"><span class="pre">bc_params</span></code> and <code class="docutils literal notranslate"><span class="pre">bc_target</span></code> will be described in detail in other sections of this documentation, but let us focus here on the parameter, <code class="docutils literal notranslate"><span class="pre">bc_type</span></code>. The <code class="docutils literal notranslate"><span class="pre">bc_type</span></code> (an integer) is a coded form of the physical boundary condition that we want to impose, and this is done point-wise. This means that along a face of the domain, different physical boundary conditions
can be combined. For example, one may wish to impose an inflow in the middle of a wall in order to represent a localized inlet jet or an open boundary. Four physical boundary conditions are implemented in the GC-NSCBC framework: <code class="docutils literal notranslate"><span class="pre">Inflow</span></code>, <code class="docutils literal notranslate"><span class="pre">Outflow</span></code>, <code class="docutils literal notranslate"><span class="pre">SlipWall</span></code>, <code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Inflow</span></code> and <code class="docutils literal notranslate"><span class="pre">Outflow</span></code> conditions rely on different models for the waves entering into the domain, and are computed in the routine <code class="docutils literal notranslate"><span class="pre">compute_waves</span></code> in <code class="docutils literal notranslate"><span class="pre">impose_NSCBC_(dir)d.F90</span></code>.
For example in 2D, <code class="docutils literal notranslate"><span class="pre">Inflow</span></code> requires models for three incoming waves. Thus, three relaxation parameters are needed: <code class="docutils literal notranslate"><span class="pre">relax_U</span></code>, <code class="docutils literal notranslate"><span class="pre">relax_V</span></code> and <code class="docutils literal notranslate"><span class="pre">relax_T</span></code>. Also, three state target
values are needed: <code class="docutils literal notranslate"><span class="pre">TARGET_VX</span></code>, <code class="docutils literal notranslate"><span class="pre">TARGET_VY</span></code> and <code class="docutils literal notranslate"><span class="pre">TARGET_TEMPERATURE</span></code>. For an <code class="docutils literal notranslate"><span class="pre">Outflow</span></code>, only one wave is leaving the domain, so only <code class="docutils literal notranslate"><span class="pre">TARGET_PRESSURE</span></code> is needed, and
the relaxation parameter is controlled with <code class="docutils literal notranslate"><span class="pre">sigma_out</span></code>. Note that transverse terms can be included in the computation of the waves, and the amount of contribution is controlled
by the parameter <code class="docutils literal notranslate"><span class="pre">beta</span></code>, with values between 0 (full contribution) and 1 (no contribution). A negative input value of <code class="docutils literal notranslate"><span class="pre">beta</span></code> indicates that <code class="docutils literal notranslate"><span class="pre">beta</span></code> will be adjusted dynamically with the Mach number of the local flow (see <a class="reference external" href="https://ccse.lbl.gov/people/motheau/Manuscripts_website/2017_AIAA_CFD_Motheau.pdf">Motheau et al. (2017) AIAA Journal</a> and other references therein for details).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">impose_NSCBC_(dir)d.F90</span></code> routine is organized as follows:</p>
<ul class="simple">
<li><p>First, data in ghost-cells along the direction at corners are treated. This is because we have to use a one-sided derivative to compute transverse terms at corners.</p></li>
<li><p>For each cell, we compute derivatives in the normal and tangential directions of the face.</p></li>
<li><p>We call bcnormal to get: the physical boundary (<code class="docutils literal notranslate"><span class="pre">bc_type</span></code>), the target state values (<code class="docutils literal notranslate"><span class="pre">bc_target</span></code>), and the associated numerical parameters (<code class="docutils literal notranslate"><span class="pre">bc_params</span></code>).</p></li>
<li><p>Then we compute the NSCBC waves.</p></li>
<li><p>The last step is GC-NSCBC procedure to recompute the values in ghost-cells according to the characteristic waves that have been computed in the previous step.</p></li>
</ul>
<p>This procedure is done for each face of the domain.</p>
<p>Below is an example to achieve an inflow/outflow along the x-axis of a channel, periodic in y. Note how the <code class="docutils literal notranslate"><span class="pre">bc_params</span></code> and <code class="docutils literal notranslate"><span class="pre">bc_target</span></code> arrays are constructed at the end of the routine.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  subroutine bcnormal(x,u_int,u_ext,dir,sgn,time,bc_type,bc_params,bc_target)

  use probdata_module
  use eos_type_module
  use eos_module
  use meth_params_module, only : URHO, UMX, UMY, UMZ, UTEMP, UEDEN, UEINT, UFS
  use network, only: nspecies, naux, molec_wt
  use prob_params_module, only : Interior, Inflow, Outflow, SlipWall, NoSlipWall, &amp;
                                 problo, probhi


  use bl_constants_module, only: M_PI

  implicit none

  double precision :: x(3), time
  double precision :: u_int(*),u_ext(*)
  integer :: dir,sgn
  integer, optional, intent(out) :: bc_type
  double precision, optional, intent(out) :: bc_params(6)
  double precision, optional, intent(out) :: bc_target(5)

  type (eos_t) :: eos_state
  double precision :: u(3)
  double precision :: y
  double precision :: relax_U, relax_V, relax_W, relax_T, beta, sigma_out
  integer :: flag_nscbc, which_bc_type

  flag_nscbc = 0

  ! When optional arguments are present, GC-NSCBC is activated
  ! Generic values are auto-filled for numerical parameters,
  ! but should be set by the user for each BC
  ! Note that in the impose_NSCBC_xD.f90 routine, not all parameters are used in same time
  if (present(bc_type).and.present(bc_params).and.present(bc_target)) then

    flag_nscbc = 1
    relax_U = 0.5d0 ! For inflow only, relax parameter for x_velocity
    relax_V = 0.5d0 ! For inflow only, relax parameter for y_velocity
    relax_W = 0.5d0 ! For inflow only, relax parameter for z_velocity
    relax_T = 0.2d0 ! For inflow only, relax parameter for temperature
    beta = 0.2d0  ! Control the contribution of transverse terms
    sigma_out = 0.25d0 ! For outflow only, relax parameter
    which_bc_type = Interior ! This is to ensure that nothing will be done if the user don&#39;t set anything
  endif

  call build(eos_state)

  ! at low X
  if (dir == 1) then
    if (sgn == 1) then

      relax_U = 10.0d0
      relax_V = 2.0d0
      relax_T = - relax_V
      beta = 0.6d0

      which_bc_type = Inflow

      u(1) = u_ref
      u(2) = 0.0d0
      u(3) = 0.0d0
      eos_state % massfrac(1) = 1.d0
      eos_state % p = p_ref
      eos_state % T = T_ref
      call eos_tp(eos_state)

    end if

  ! at hi X
    if (sgn == -1) then

      ! Set outflow pressure
      which_bc_type = Outflow
      sigma_out = 0.28d0
      beta = -0.60d0

      u(1:3) = 0.d0
      eos_state % massfrac(1) = 1.d0
      eos_state % p = p_ref
      eos_state % T = T_ref
      call eos_tp(eos_state)

    end if
  end if

  ! at low Y
  if (dir == 2) then
    if (sgn == 1) then

      ! Do nothing, this is periodic

    end if

  ! at hi Y
    if (sgn == -1) then

     ! Do nothing, this is periodic

    end if
  end if


     u_ext(UFS:UFS+nspecies-1) = eos_state % massfrac * eos_state % rho
     u_ext(URHO)               = eos_state % rho
     u_ext(UMX)                = eos_state % rho  *  u(1)
     u_ext(UMY)                = eos_state % rho  *  u(2)
     u_ext(UMZ)                = eos_state % rho  *  u(3)
     u_ext(UTEMP)              = eos_state % T
     u_ext(UEINT)              = eos_state % rho  *   eos_state % e
     u_ext(UEDEN)              = eos_state % rho  *  (eos_state % e + 0.5d0 * (u(1)**2 + u(2)**2) + u(3)**2)

  ! Here the optional parameters are filled by the local variables if they were present
  if (flag_nscbc == 1) then
    bc_type = which_bc_type
    bc_params(1) = relax_T!  For inflow only, relax parameter for temperature
    bc_params(2) = relax_U ! For inflow only, relax parameter for x_velocity
    bc_params(3) = relax_V ! For inflow only, relax parameter for y_velocity
    bc_params(4) = relax_W ! For inflow only, relax parameter for z_velocity
    bc_params(5) = beta  ! Control the contribution of transverse terms.
    bc_params(6) = sigma_out ! For outflow only, relax parameter
    bc_target(1) = U_ext(UMX)/U_ext(URHO)  ! Target for Inflow
    bc_target(2) = U_ext(UMY)/U_ext(URHO)  ! Target for Inflow
    bc_target(3) = U_ext(UMZ)/U_ext(URHO)  ! Target for Inflow
    bc_target(4) = U_ext(UTEMP)            ! Target for Inflow
    bc_target(5) = eos_state%p             ! Target for Outflow
  end if

  call destroy(eos_state)

end subroutine bcnormal
</pre></div>
</div>
<p>The choice of the relaxation parameters in  <code class="docutils literal notranslate"><span class="pre">bc_params</span></code> is case-dependent, unfortunately. Some trial-and-error is often required to find the best values. However, we suggest the the following based on literature and practical experience:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">relax_U</span></code>, <code class="docutils literal notranslate"><span class="pre">relax_V</span></code> and <code class="docutils literal notranslate"><span class="pre">relax_W</span></code> should have values near 0.2. Higher values will impose the velocity more ‚Äústrongly‚Äù, but will likely lead to more unphysical waves reflection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">relax_T</span></code> must be a negative value, typically near -0.2.</p></li>
<li><p>For outflow boundaries, <code class="docutils literal notranslate"><span class="pre">sigma_out</span></code> = 0.25 is often reported to be a good choice.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">beta</span></code> must be between 0 and 1; it controls the contribution of transverse terms. The choice for this parameter is more complicated. For outflows, it should be close to the Mach number. For some cases, a spatially averaged Mach number will provide good results, while for other cases, the point-wise local Mach number is better. <code class="docutils literal notranslate"><span class="pre">beta</span></code> will be set to the local Mach number if it is set to a negative value in the inputs. For inflows, it has been found that a value of 0.5 provides good results, but it may lead to instabilities, and for some case turning off the transverse terms (beta=1) will be better.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Testing.html" class="btn btn-neutral float-left" title="Testing and Verification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="geometry/EB.html" class="btn btn-neutral float-right" title="Geometry treatment in PeleC" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright AMReX Copyright (c) 2021, The Regents of the University of California, through Lawrence Berkeley National Laboratory, the Alliance for Sustainable Energy, LLC., through National Renewable Energy Laboratory, National Technology and Engineering Solutions of Sandia, LLC, and UT-Battelle, LLC (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All rights reserved..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>