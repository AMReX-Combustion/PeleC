module advection_util_module

  implicit none

  private

  public enforce_minimum_density, compute_cfl, ctoprim, srctoprim, dflux, &
         limit_hydro_fluxes_on_small_dens

contains

  subroutine enforce_minimum_density(uin,uin_lo,uin_hi, &
                                     uout,uout_lo,uout_hi, &
                                     vol,vol_lo,vol_hi, &
                                     lo,hi,mass_added,eint_added, &
                                     eden_added,frac_change,verbose) &
                                     bind(C, name="enforce_minimum_density")

    use meth_params_module, only : NVAR, URHO, UEINT, UEDEN, small_dens, density_reset_method
    use amrex_constants_module, only : ZERO

    implicit none

    integer, intent(in) :: lo(3), hi(3), verbose
    integer, intent(in) ::  uin_lo(3),  uin_hi(3)
    integer, intent(in) :: uout_lo(3), uout_hi(3)
    integer, intent(in) ::  vol_lo(3),  vol_hi(3)

    double precision, intent(in) ::  uin( uin_lo(1): uin_hi(1), uin_lo(2): uin_hi(2), uin_lo(3): uin_hi(3),NVAR)
    double precision, intent(inout) :: uout(uout_lo(1):uout_hi(1),uout_lo(2):uout_hi(2),uout_lo(3):uout_hi(3),NVAR)
    double precision, intent(in) ::  vol( vol_lo(1): vol_hi(1), vol_lo(2): vol_hi(2), vol_lo(3): vol_hi(3))
    double precision, intent(inout) :: mass_added, eint_added, eden_added, frac_change

    ! Local variables
    integer          :: i,ii,j,jj,k,kk
    integer          :: i_set, j_set, k_set
    double precision :: max_dens
    double precision :: unew(NVAR)
    integer          :: num_positive_zones

    double precision :: initial_mass, final_mass
    double precision :: initial_eint, final_eint
    double precision :: initial_eden, final_eden

    logical :: have_reset

    initial_mass = ZERO
    final_mass   = ZERO

    initial_eint = ZERO
    final_eint   = ZERO

    initial_eden = ZERO
    final_eden   = ZERO

    max_dens = ZERO

    have_reset = .false.

    do k = lo(3),hi(3)
       do j = lo(2),hi(2)
          do i = lo(1),hi(1)

             initial_mass = initial_mass + uout(i,j,k,URHO ) * vol(i,j,k)
             initial_eint = initial_eint + uout(i,j,k,UEINT) * vol(i,j,k)
             initial_eden = initial_eden + uout(i,j,k,UEDEN) * vol(i,j,k)

             if (uout(i,j,k,URHO) .eq. ZERO) then

                print *,'DENSITY EXACTLY ZERO AT CELL ',i,j,k
                print *,'  in grid ',lo(1),lo(2),lo(3),hi(1),hi(2),hi(3)
                call bl_error("Error:: advection_util_nd.f90 :: enforce_minimum_density")

             else if (uout(i,j,k,URHO) < small_dens) then

                have_reset = .true.

                ! Store the maximum (negative) fractional change in the density

                if ( uout(i,j,k,URHO) < ZERO .and. &
                     (uout(i,j,k,URHO) - uin(i,j,k,URHO)) / uin(i,j,k,URHO) < frac_change) then

                   frac_change = (uout(i,j,k,URHO) - uin(i,j,k,URHO)) / uin(i,j,k,URHO)

                endif

                if (density_reset_method == 1) then

                   ! Reset to the characteristics of the adjacent state with the highest density.

                   max_dens = uout(i,j,k,URHO)
                   i_set = i
                   j_set = j
                   k_set = k
                   do kk = -1,1
                      do jj = -1,1
                         do ii = -1,1
                            if (i+ii.ge.lo(1) .and. j+jj.ge.lo(2) .and. k+kk.ge.lo(3) .and. &
                                 i+ii.le.hi(1) .and. j+jj.le.hi(2) .and. k+kk.le.hi(3)) then
                               if (uout(i+ii,j+jj,k+kk,URHO) .gt. max_dens) then
                                  i_set = i+ii
                                  j_set = j+jj
                                  k_set = k+kk
                                  max_dens = uout(i_set,j_set,k_set,URHO)
                               endif
                            endif
                         end do
                      end do
                   end do

                   if (max_dens < small_dens) then

                      ! We could not find any nearby zones with sufficient density.

                      call reset_to_small_state(uin(i,j,k,:), uout(i,j,k,:), [i, j, k], lo, hi, verbose)

                   else

                      unew = uout(i_set,j_set,k_set,:)

                      call reset_to_zone_state(uin(i,j,k,:), uout(i,j,k,:), unew(:), [i, j, k], lo, hi, verbose)

                   endif

                else if (density_reset_method == 2) then

                   ! Reset to the average of adjacent zones. The median is independently calculated for each variable.

                   num_positive_zones = 0
                   unew(:) = ZERO

                   do kk = -1, 1
                      do jj = -1, 1
                         do ii = -1, 1
                            if (i+ii.ge.lo(1) .and. j+jj.ge.lo(2) .and. k+kk.ge.lo(3) .and. &
                                i+ii.le.hi(1) .and. j+jj.le.hi(2) .and. k+kk.le.hi(3)) then
                               if (uout(i+ii,j+jj,k+kk,URHO) .ge. small_dens) then
                                  unew(:) = unew(:) + uout(i+ii,j+jj,k+kk,:)
                                  num_positive_zones = num_positive_zones + 1
                               endif
                            endif
                         enddo
                      enddo
                   enddo

                   if (num_positive_zones == 0) then

                      ! We could not find any nearby zones with sufficient density.

                      call reset_to_small_state(uin(i,j,k,:), uout(i,j,k,:), [i, j, k], lo, hi, verbose)

                   else

                      unew(:) = unew(:) / num_positive_zones

                      call reset_to_zone_state(uin(i,j,k,:), uout(i,j,k,:), unew(:), [i, j, k], lo, hi, verbose)

                   endif

                elseif (density_reset_method == 3) then

                   ! Reset to the original zone state.

                   if (uin(i,j,k,URHO) < small_dens) then

                      call reset_to_small_state(uin(i,j,k,:), uout(i,j,k,:), [i, j, k], lo, hi, verbose)

                   else

                      unew(:) = uin(i,j,k,:)

                      call reset_to_zone_state(uin(i,j,k,:), uout(i,j,k,:), unew(:), [i, j, k], lo, hi, verbose)

                   endif

                else

                   call bl_error("Unknown density_reset_method in subroutine enforce_minimum_density.")

                endif

             end if

             final_mass = final_mass + uout(i,j,k,URHO ) * vol(i,j,k)
             final_eint = final_eint + uout(i,j,k,UEINT) * vol(i,j,k)
             final_eden = final_eden + uout(i,j,k,UEDEN) * vol(i,j,k)

          enddo
       enddo
    enddo

    if ( have_reset ) then
       mass_added = mass_added + final_mass - initial_mass
       eint_added = eint_added + final_eint - initial_eint
       eden_added = eden_added + final_eden - initial_eden
    endif

  end subroutine enforce_minimum_density



  subroutine reset_to_small_state(old_state, new_state, idx, lo, hi, verbose)

    use amrex_constants_module, only: ZERO
    use fuego_chemistry, only: nspecies, naux
    use meth_params_module, only: NVAR, URHO, UMX, UMY, UMZ, UTEMP, UEINT, UEDEN, UFS, small_temp, small_dens, npassive, upass_map
    use eos_type_module
    use eos_module, only: eos_rt
    use pelec_util_module, only: position
    implicit none

    double precision :: old_state(NVAR), new_state(NVAR)
    integer          :: idx(3), lo(3), hi(3), verbose

    integer          :: n, ipassive
    type (eos_t)     :: eos_state

    ! If no neighboring zones are above small_dens, our only recourse
    ! is to set the density equal to small_dens, and the temperature
    ! equal to small_temp. We set the velocities to zero,
    ! though any choice here would be arbitrary.

    call build(eos_state)

    if (verbose .gt. 0) then
       print *,'   '
       if (new_state(URHO) < ZERO) then
          print *,'>>> RESETTING NEG.  DENSITY AT ',idx(1),idx(2),idx(3)
       else
          print *,'>>> RESETTING SMALL DENSITY AT ',idx(1),idx(2),idx(3)
       endif
       print *,'>>> FROM ',new_state(URHO),' TO ',small_dens
       print *,'>>> IN GRID ',lo(1),lo(2),lo(3),hi(1),hi(2),hi(3)
       print *,'>>> ORIGINAL DENSITY FOR OLD STATE WAS ',old_state(URHO)
       print *,'   '
    end if

    do ipassive = 1, npassive
       n = upass_map(ipassive)
       new_state(n) = new_state(n) * (small_dens / new_state(URHO))
    end do

    eos_state % rho      = small_dens
    eos_state % T        = small_temp
    eos_state % massfrac = new_state(UFS:UFS+nspecies-1) / small_dens
    eos_state % aux      = new_state(UFS:UFS+naux-1) / small_dens

    call eos_rt(eos_state)

    new_state(URHO ) = eos_state % rho
    new_state(UTEMP) = eos_state % T

    new_state(UMX  ) = ZERO
    new_state(UMY  ) = ZERO
    new_state(UMZ  ) = ZERO

    new_state(UEINT) = eos_state % rho * eos_state % e
    new_state(UEDEN) = new_state(UEINT)

    call destroy(eos_state)

  end subroutine reset_to_small_state



  subroutine reset_to_zone_state(old_state, new_state, input_state, idx, lo, hi, verbose)

    use amrex_constants_module, only: ZERO
    use meth_params_module, only: NVAR, URHO

    implicit none

    double precision :: old_state(NVAR), new_state(NVAR), input_state(NVAR)
    integer          :: idx(3), lo(3), hi(3), verbose

    if (verbose .gt. 0) then
       if (new_state(URHO) < ZERO) then
          print *,'   '
          print *,'>>> RESETTING NEG.  DENSITY AT ',idx(1),idx(2),idx(3)
          print *,'>>> FROM ',new_state(URHO),' TO ',input_state(URHO)
          print *,'>>> IN GRID ',lo(1),lo(2),lo(3),hi(1),hi(2),hi(3)
          print *,'>>> ORIGINAL DENSITY FOR OLD STATE WAS ',old_state(URHO)
          print *,'   '
       else
          print *,'   '
          print *,'>>> RESETTING SMALL DENSITY AT ',idx(1),idx(2),idx(3)
          print *,'>>> FROM ',new_state(URHO),' TO ',input_state(URHO)
          print *,'>>> IN GRID ',lo(1),lo(2),lo(3),hi(1),hi(2),hi(3)
          print *,'>>> ORIGINAL DENSITY FOR OLD STATE WAS ',old_state(URHO)
          print *,'   '
       end if
    end if

    new_state(:) = input_state(:)

  end subroutine reset_to_zone_state



  subroutine compute_cfl(q, q_lo, q_hi, &
                         qaux, qa_lo, qa_hi, &
                         lo, hi, dt, dx, courno) &
                         bind(C, name = "compute_cfl")

    use amrex_constants_module, only: ZERO, ONE
    use meth_params_module, only: QVAR, QRHO, QU, QV, QW, QC, NQAUX
    use prob_params_module, only: dim

    implicit none

    integer :: lo(3), hi(3)
    integer :: q_lo(3), q_hi(3), qa_lo(3), qa_hi(3)

    double precision :: q(q_lo(1):q_hi(1),q_lo(2):q_hi(2),q_lo(3):q_hi(3),QVAR)
    double precision :: qaux(qa_lo(1):qa_hi(1),qa_lo(2):qa_hi(2),qa_lo(3):qa_hi(3),NQAUX)
    double precision :: dt, dx(3), courno

    double precision :: courx, coury, courz, courmx, courmy, courmz
    double precision :: dtdx, dtdy, dtdz
    integer          :: i, j, k

    ! Compute running max of Courant number over grids

    courmx = courno
    courmy = courno
    courmz = courno

    dtdx = dt / dx(1)

    if (dim .ge. 2) then
       dtdy = dt / dx(2)
    else
       dtdy = ZERO
    endif

    if (dim .eq. 3) then
       dtdz = dt / dx(3)
    else
       dtdz = ZERO
    endif

    do k = lo(3),hi(3)
       do j = lo(2),hi(2)
          do i = lo(1),hi(1)

             courx = ( qaux(i,j,k,QC) + abs(q(i,j,k,QU)) ) * dtdx
             coury = ( qaux(i,j,k,QC) + abs(q(i,j,k,QV)) ) * dtdy
             courz = ( qaux(i,j,k,QC) + abs(q(i,j,k,QW)) ) * dtdz

             courmx = max( courmx, courx )
             courmy = max( courmy, coury )
             courmz = max( courmz, courz )

             if (courx .gt. ONE) then
                print *,'   '
                call bl_warning("Warning:: advection_util_nd.F90 :: CFL violation in compute_cfl")
                print *,'>>> ... (u+c) * dt / dx > 1 ', courx
                print *,'>>> ... at cell (i,j,k)   : ', i, j, k
                print *,'>>> ... u, c                ', q(i,j,k,QU), qaux(i,j,k,QC)
                print *,'>>> ... density             ', q(i,j,k,QRHO)
             end if

             if (coury .gt. ONE) then
                print *,'   '
                call bl_warning("Warning:: advection_util_nd.F90 :: CFL violation in compute_cfl")
                print *,'>>> ... (v+c) * dt / dx > 1 ', coury
                print *,'>>> ... at cell (i,j,k)   : ', i,j,k
                print *,'>>> ... v, c                ', q(i,j,k,QV), qaux(i,j,k,QC)
                print *,'>>> ... density             ', q(i,j,k,QRHO)
             end if

             if (courz .gt. ONE) then
                print *,'   '
                call bl_warning("Warning:: advection_util_nd.F90 :: CFL violation in compute_cfl")
                print *,'>>> ... (w+c) * dt / dx > 1 ', courz
                print *,'>>> ... at cell (i,j,k)   : ', i, j, k
                print *,'>>> ... w, c                ', q(i,j,k,QW), qaux(i,j,k,QC)
                print *,'>>> ... density             ', q(i,j,k,QRHO)
             end if

          enddo
       enddo
    enddo

    courno = max( courmx, courmy, courmz )

  end subroutine compute_cfl


  subroutine ctoprim(lo, hi, &
                     uin, uin_lo, uin_hi, &
                     q,     q_lo,   q_hi, &
                     qaux, qa_lo,  qa_hi) bind(C, name = "ctoprim")

    use fuego_chemistry, only : Ru, nspecies, naux
    use eos_module, only : eos_re
    use eos_type_module
    use meth_params_module, only : NVAR, URHO, UMX, UMZ, UEDEN, UTEMP, &
                                   QVAR, QRHO, QU, QV, QW, &
                                   QREINT, QPRES, QTEMP, QGAME, QFS, QFX, &
                                   QC, QCSML, QGAMC, QDPDR, QDPDE, QRSPEC, NQAUX, &
                                   npassive, upass_map, qpass_map
    use amrex_constants_module, only: ZERO, HALF, ONE
    use pelec_util_module, only: position
    implicit none

    integer, intent(in) :: lo(3), hi(3)
    integer, intent(in) :: uin_lo(3), uin_hi(3)
    integer, intent(in) :: q_lo(3), q_hi(3)
    integer, intent(in) :: qa_lo(3), qa_hi(3)

    double precision, intent(in   ) :: uin(uin_lo(1):uin_hi(1),uin_lo(2):uin_hi(2),uin_lo(3):uin_hi(3),NVAR)
    double precision, intent(inout) :: q(q_lo(1):q_hi(1),q_lo(2):q_hi(2),q_lo(3):q_hi(3),QVAR)
    double precision, intent(inout) :: qaux(qa_lo(1):qa_hi(1),qa_lo(2):qa_hi(2),qa_lo(3):qa_hi(3),NQAUX)

    double precision, parameter :: small = 1.d-8

    integer          :: i, j, k
    integer          :: n, nq, ipassive
    double precision :: kineng, rhoinv
    double precision :: vel(3)

    type (eos_t) :: eos_state

    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             q(i,j,k,QRHO) = uin(i,j,k,URHO)

             rhoinv = ONE/q(i,j,k,QRHO)
             vel = uin(i,j,k,UMX:UMZ) * rhoinv

             q(i,j,k,QU:QW) = vel

             kineng = HALF * q(i,j,k,QRHO) * (q(i,j,k,QU)**2 + q(i,j,k,QV)**2 + q(i,j,k,QW)**2)

             q(i,j,k,QREINT) = (uin(i,j,k,UEDEN) - kineng) * rhoinv

             q(i,j,k,QTEMP) = uin(i,j,k,UTEMP)
          enddo
       enddo
    enddo

    ! Load passively advected quatities into q
    do ipassive = 1, npassive
       n  = upass_map(ipassive)
       nq = qpass_map(ipassive)
       do k = lo(3),hi(3)
          do j = lo(2),hi(2)
             do i = lo(1),hi(1)
                q(i,j,k,nq) = uin(i,j,k,n)/q(i,j,k,QRHO)
             enddo
          enddo
       enddo
    enddo

    call build(eos_state)

    ! get gamc, p, T, c, csml using q state
    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             eos_state % T        = q(i,j,k,QTEMP )
             eos_state % rho      = q(i,j,k,QRHO  )
             eos_state % e        = q(i,j,k,QREINT)
             eos_state % massfrac = q(i,j,k,QFS:QFS+nspecies-1)
             eos_state % aux      = q(i,j,k,QFX:QFX+naux-1)

             call eos_re(eos_state)

             q(i,j,k,QTEMP)  = eos_state % T
             q(i,j,k,QREINT) = eos_state % e * q(i,j,k,QRHO)
             q(i,j,k,QPRES)  = eos_state % p
             q(i,j,k,QGAME)  = q(i,j,k,QPRES) / q(i,j,k,QREINT) + ONE

             qaux(i,j,k,QDPDR)  = eos_state % dpdr_e
             qaux(i,j,k,QDPDE)  = eos_state % dpde

             qaux(i,j,k,QGAMC)  = eos_state % gam1
             qaux(i,j,k,QC   )  = eos_state % cs
             qaux(i,j,k,QCSML)  = max(small, small * qaux(i,j,k,QC))
             qaux(i,j,k,QRSPEC)  = Ru/eos_state % wbar
          enddo
       enddo
    enddo

    call destroy(eos_state)

  end subroutine ctoprim



  subroutine srctoprim(lo, hi, &
                       q,     q_lo,   q_hi, &
                       qaux, qa_lo,  qa_hi, &
                       src, src_lo, src_hi, &
                       srcQ,srQ_lo, srQ_hi) bind(C, name = "srctoprim")

    use meth_params_module, only : NVAR, URHO, UMX, UMY, UMZ, UEDEN, &
                                   QVAR, QRHO, QU, QV, QW, &
                                   QREINT, QPRES, QDPDR, QDPDE, NQAUX, &
                                   npassive, upass_map, qpass_map
    use amrex_constants_module, only: ZERO, HALF, ONE
    use pelec_util_module, only: position

    implicit none

    integer, intent(in) :: lo(3), hi(3)
    integer, intent(in) :: q_lo(3), q_hi(3)
    integer, intent(in) :: qa_lo(3),   qa_hi(3)
    integer, intent(in) :: src_lo(3), src_hi(3)
    integer, intent(in) :: srQ_lo(3), srQ_hi(3)

    double precision, intent(in   ) :: q(q_lo(1):q_hi(1),q_lo(2):q_hi(2),q_lo(3):q_hi(3),QVAR)
    double precision, intent(in   ) :: qaux(qa_lo(1):qa_hi(1),qa_lo(2):qa_hi(2),qa_lo(3):qa_hi(3),NQAUX)
    double precision, intent(in   ) :: src(src_lo(1):src_hi(1),src_lo(2):src_hi(2),src_lo(3):src_hi(3),NVAR)
    double precision, intent(inout) :: srcQ(srQ_lo(1):srQ_hi(1),srQ_lo(2):srQ_hi(2),srQ_lo(3):srQ_hi(3),QVAR)

    integer          :: i, j, k
    integer          :: n, nq, ipassive
    double precision :: rhoinv

    srcQ(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),:) = ZERO

    ! compute srcQ terms
    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             rhoinv = ONE / q(i,j,k,QRHO)

             srcQ(i,j,k,QRHO  ) = src(i,j,k,URHO)
             srcQ(i,j,k,QU    ) = (src(i,j,k,UMX) - q(i,j,k,QU) * srcQ(i,j,k,QRHO)) * rhoinv
             srcQ(i,j,k,QV    ) = (src(i,j,k,UMY) - q(i,j,k,QV) * srcQ(i,j,k,QRHO)) * rhoinv
             srcQ(i,j,k,QW    ) = (src(i,j,k,UMZ) - q(i,j,k,QW) * srcQ(i,j,k,QRHO)) * rhoinv
             srcQ(i,j,k,QREINT) = src(i,j,k,UEDEN) &
                  - q(i,j,k,QU)*src(i,j,k,UMX) &
                  - q(i,j,k,QV)*src(i,j,k,UMY) &
                  - q(i,j,k,QW)*src(i,j,k,UMZ) &
                  + src(i,j,k,URHO) * (q(i,j,k,QU)**2 + q(i,j,k,QV)**2 + q(i,j,k,QW)**2)
             srcQ(i,j,k,QPRES ) = qaux(i,j,k,QDPDE)*(srcQ(i,j,k,QREINT) - &
                                  q(i,j,k,QREINT)*srcQ(i,j,k,QRHO)*rhoinv) * rhoinv + &
                                  qaux(i,j,k,QDPDR)*srcQ(i,j,k,QRHO)
          enddo
       enddo
    enddo

    do ipassive = 1, npassive
       n = upass_map(ipassive)
       nq = qpass_map(ipassive)

       do k = lo(3), hi(3)
          do j = lo(2), hi(2)
             do i = lo(1), hi(1)
                srcQ(i,j,k,nq) = ( src(i,j,k,n) - q(i,j,k,nq) * srcQ(i,j,k,QRHO) ) / &
                                 q(i,j,k,QRHO)
             enddo
          enddo
       enddo

    enddo

  end subroutine srctoprim



  ! Given a conservative state and its corresponding primitive state, calculate the
  ! corresponding flux in a given direction.

  function dflux(u, q, dir, idx, include_pressure) result(flux)

    use amrex_constants_module, only: ZERO
    use meth_params_module, only: NVAR, URHO, UMX, UMZ, UEDEN, UEINT, &
                                  QVAR, QU, QPRES, &
                                  npassive, upass_map
    implicit none

    integer :: dir, idx(3)
    double precision :: u(NVAR), q(QVAR), flux(NVAR)
    logical, optional :: include_pressure

    double precision :: v_adv
    integer :: ipassive, n
    ! Set everything to zero; this default matters because some
    ! quantities like temperature are not updated through fluxes.

    flux = ZERO

    ! Determine the advection speed based on the flux direction.

    v_adv = q(QU + dir - 1)

    ! Core quantities (density, momentum, energy).

    flux(URHO) = u(URHO) * v_adv
    flux(UMX:UMZ) = u(UMX:UMZ) * v_adv
    flux(UEDEN) = (u(UEDEN) + q(QPRES)) * v_adv
    flux(UEINT) = u(UEINT) * v_adv

    ! Optionally include the pressure term in the momentum flux.
    ! It is optional because for some geometries we cannot write
    ! the pressure term in a conservative form.

    if (present(include_pressure)) then
       if (include_pressure) then
          flux(UMX + dir - 1) = flux(UMX + dir - 1) + q(QPRES)
       endif
    endif

    ! Hybrid flux.

    ! Passively advected quantities.

    do ipassive = 1, npassive

       n = upass_map(ipassive)
       flux(n) = u(n) * v_adv

    enddo

  end function dflux



  subroutine limit_hydro_fluxes_on_small_dens(u,u_lo,u_hi, &
                                              q,q_lo,q_hi, &
                                              vol,vol_lo,vol_hi, &
                                              flux1,flux1_lo,flux1_hi, &
                                              area1,area1_lo,area1_hi, &
#if (BL_SPACEDIM >= 2)
                                              flux2,flux2_lo,flux2_hi, &
                                              area2,area2_lo,area2_hi, &
#endif
#if (BL_SPACEDIM == 3)
                                              flux3,flux3_lo,flux3_hi, &
                                              area3,area3_lo,area3_hi, &
#endif
                                              lo,hi,dt,dx)

    use amrex_constants_module, only: ZERO, HALF, ONE, TWO
    use meth_params_module, only: NVAR, QVAR, URHO, UEINT, UFS, UFX, &
                                  small_dens, small_temp, cfl, &
                                  allow_small_energy, allow_negative_energy
    use prob_params_module, only: dim, coord_type, dg
    use amrex_mempool_module, only: bl_allocate, bl_deallocate
    use fuego_chemistry, only: nspecies, naux
    use eos_type_module
    use eos_module, only: eos_rt

    implicit none

    integer, intent(in) :: u_lo(3), u_hi(3)
    integer, intent(in) :: q_lo(3), q_hi(3)
    integer, intent(in) :: vol_lo(3), vol_hi(3)
    integer, intent(in) :: lo(3), hi(3)
    integer, intent(in) :: flux1_lo(3), flux1_hi(3)
    integer, intent(in) :: area1_lo(3), area1_hi(3)
#if (BL_SPACEDIM >= 2)
    integer, intent(in) :: flux2_lo(3), flux2_hi(3)
    integer, intent(in) :: area2_lo(3), area2_hi(3)
#endif
#if (BL_SPACEDIM == 3)
    integer, intent(in) :: flux3_lo(3), flux3_hi(3)
    integer, intent(in) :: area3_lo(3), area3_hi(3)
#endif

    double precision, intent(in   ) :: dt, dx(3)

    double precision, intent(in   ) :: u(u_lo(1):u_hi(1),u_lo(2):u_hi(2),u_lo(3):u_hi(3),NVAR)
    double precision, intent(in   ) :: q(q_lo(1):q_hi(1),q_lo(2):q_hi(2),q_lo(3):q_hi(3),QVAR)
    double precision, intent(in   ) :: vol(vol_lo(1):vol_hi(1),vol_lo(2):vol_hi(2),vol_lo(3):vol_hi(3))
    double precision, intent(inout) :: flux1(flux1_lo(1):flux1_hi(1),flux1_lo(2):flux1_hi(2),flux1_lo(3):flux1_hi(3),NVAR)
    double precision, intent(in   ) :: area1(area1_lo(1):area1_hi(1),area1_lo(2):area1_hi(2),area1_lo(3):area1_hi(3))
#if (BL_SPACEDIM >= 2)
    double precision, intent(inout) :: flux2(flux2_lo(1):flux2_hi(1),flux2_lo(2):flux2_hi(2),flux2_lo(3):flux2_hi(3),NVAR)
    double precision, intent(in   ) :: area2(area2_lo(1):area2_hi(1),area2_lo(2):area2_hi(2),area2_lo(3):area2_hi(3))
#endif
#if (BL_SPACEDIM == 3)
    double precision, intent(inout) :: flux3(flux3_lo(1):flux3_hi(1),flux3_lo(2):flux3_hi(2),flux3_lo(3):flux3_hi(3),NVAR)
    double precision, intent(in   ) :: area3(area3_lo(1):area3_hi(1),area3_lo(2):area3_hi(2),area3_lo(3):area3_hi(3))
#endif

    double precision, pointer :: thetap_dens(:,:,:), thetam_dens(:,:,:)
    double precision, pointer :: thetap_rhoe(:,:,:), thetam_rhoe(:,:,:)
    double precision, pointer :: small_rhoe(:,:,:)

    integer          :: i, j, k

    double precision :: alpha_x, alpha_y, alpha_z
    double precision :: rho, drho, fluxLF(NVAR), fluxL(NVAR), fluxR(NVAR), rhoLF, drhoLF, dtdx, theta
    integer          :: dir
    logical          :: include_pressure

    type (eos_t) :: eos_state
    double precision :: rhoe, drhoe, rhoeLF, drhoeLF

    ! The following algorithm comes from Hu, Adams, and Shu (2013), JCP, 242, 169,
    ! "Positivity-preserving method for high-order conservative schemes solving
    ! compressible Euler equations." It has been modified to enforce not only positivity
    ! but also the stronger requirement that rho > small_dens. In addition, instead of
    ! limiting on pressure, we limit on (rho e).

    ! Calculate the floor (rho e) for each zone. If disallowing small energies, then the
    ! 'small' (rho e) for a given zone should be constructed from an EOS call given
    ! (small_dens, small_temp, X). (Another option would be to try and figure out what
    ! the current density is, but this is complicated by the fact that the limiter will
    ! change the final density. A related issue is that X will be different before and
    ! after the hydro update; for simplicity, we'll use the input X.) This only gives
    ! an approximate prescription for the true floor, but it is good enough.
    ! If we're just disallowing negative energies, then set the 'small' value to zero.

    call build(eos_state)

    call bl_allocate(small_rhoe,lo(1)-1,hi(1)+1,lo(2)-1,hi(2)+1,lo(3)-1,hi(3)+1)

    do k = lo(3) - 1 * dg(3), hi(3) + 1 * dg(3)
       do j = lo(2) - 1 * dg(2), hi(2) + 1 * dg(2)
          do i = lo(1) - 1 * dg(1), hi(1) + 1 * dg(1)

             if (allow_small_energy == 0) then

                eos_state % rho      = small_dens
                eos_state % T        = small_temp
                eos_state % massfrac = u(i,j,k,UFS:UFS+nspecies-1) / u(i,j,k,URHO)
                eos_state % aux      = u(i,j,k,UFX:UFX+naux-1) / u(i,j,k,URHO)

                call eos_rt(eos_state)

                small_rhoe(i,j,k) = small_dens * eos_state % e

             else if (allow_negative_energy == 0) then

                small_rhoe(i,j,k) = ZERO

             else

                ! No limiting in this case. Set to a value large enough that it should
                ! never be obtained under normal circumstances.

                small_rhoe(i,j,k) = -1.d200

             endif

          enddo
       enddo
    enddo

    call destroy(eos_state)

    ! We implement the flux limiter on a dimension-by-dimension basis, starting with the x-direction.

    call bl_allocate(thetap_dens,lo(1)-1,hi(1)+1,lo(2)-1,hi(2)+1,lo(3)-1,hi(3)+1)
    call bl_allocate(thetam_dens,lo(1)-1,hi(1)+1,lo(2)-1,hi(2)+1,lo(3)-1,hi(3)+1)
    call bl_allocate(thetap_rhoe,lo(1)-1,hi(1)+1,lo(2)-1,hi(2)+1,lo(3)-1,hi(3)+1)
    call bl_allocate(thetam_rhoe,lo(1)-1,hi(1)+1,lo(2)-1,hi(2)+1,lo(3)-1,hi(3)+1)

    thetap_dens(:,:,:) = ONE
    thetam_dens(:,:,:) = ONE
    thetap_rhoe(:,:,:) = ONE
    thetam_rhoe(:,:,:) = ONE

    dir = 1

    dtdx = dt / dx(1)

    ! Whether or not to include pressure in the cell-centered fluxes we calculate
    ! will depend on which dimensionality and coordinate system we are in.

    if (dim .eq. 1 .or. (dim .eq. 2 .and. coord_type .eq. 1)) then
       include_pressure = .false.
    else
       include_pressure = .true.
    endif

    alpha_x = (ONE / dim)
    alpha_y = (ONE / dim)
    alpha_z = (ONE / dim)

    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1) - 1, hi(1) + 1

             ! Note that this loop includes one ghost zone on either side of the current
             ! bounds, but we only need a one-sided limiter for lo(1)-1 and hi(1)+1.

             ! First we'll do the plus state, which is on the left edge of the zone.

             if (i .ge. lo(1)) then

                ! Obtain the one-sided update to the density, based on Hu et al., Eq. 11.
                ! Note that the sign convention for the notation is opposite to our convention
                ! for the edge states for the flux limiter, that is, the "plus" limiter is on
                ! the left edge of the zone and so is the "minus" rho. The flux limiter convention
                ! is analogous to the convention for the hydro reconstruction edge states.

                ! Don't do this if the density or energy is already under the floor.

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) + TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * flux1(i,j,k,URHO)

                if (rho < small_dens) then

                   ! Construct the Lax-Friedrichs flux on the interface (Equation 12).
                   ! Note that we are using the information from Equation 9 to obtain the
                   ! effective maximum wave speed, (|u| + c)_max = CFL / lambda where
                   ! lambda = dt/(dx * alpha); alpha = 1 in 1D and may be chosen somewhat
                   ! freely in multi-D as long as alpha_x + alpha_y + alpha_z = 1.

                   fluxL = dflux(u(i-1,j,k,:), q(i-1,j,k,:), dir, [i-1, j, k], include_pressure)
                   fluxR = dflux(u(i  ,j,k,:), q(i  ,j,k,:), dir, [i  , j, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_x) * (u(i-1,j,k,:) - u(i,j,k,:)))

                   ! Limit the Lax-Friedrichs flux so that it doesn't cause a density < small_dens.
                   ! To do this, first, construct the density change corresponding to the LF density flux.
                   ! Then, if this update would create a density that is less than small_dens, scale all
                   ! fluxes linearly such that the density flux gives small_dens when applied.

                   drhoLF = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   ! Obtain the final density corresponding to the LF flux.

                   rhoLF = u(i,j,k,URHO) + TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   ! Solve for theta from (1 - theta) * rhoLF + theta * rho = small_dens.

                   thetap_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                ! Now do the same for energy.

                rhoe = u(i,j,k,UEINT) + TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * flux1(i,j,k,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i-1,j,k,:), q(i-1,j,k,:), dir, [i-1, j, k], include_pressure)
                   fluxR = dflux(u(i  ,j,k,:), q(i  ,j,k,:), dir, [i  , j, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_x) * (u(i-1,j,k,:) - u(i,j,k,:)))

                   drhoeLF = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) + TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   thetap_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

             ! Now do the minus state, which is on the right edge of the zone.
             ! This uses the same logic as the above, so we don't replicate the comments.

             if (i .le. hi(1)) then

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) - TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * flux1(i+1,j,k,URHO)

                if (rho < small_dens) then

                   fluxL = dflux(u(i  ,j,k,:), q(i  ,j,k,:), dir, [i  , j, k], include_pressure)
                   fluxR = dflux(u(i+1,j,k,:), q(i+1,j,k,:), dir, [i+1, j, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_x) * (u(i,j,k,:) - u(i+1,j,k,:)))

                   drhoLF = -TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   rhoLF = u(i,j,k,URHO) - TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   thetam_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                rhoe = u(i,j,k,UEINT) - TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * flux1(i+1,j,k,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i  ,j,k,:), q(i  ,j,k,:), dir, [i  , j, k], include_pressure)
                   fluxR = dflux(u(i+1,j,k,:), q(i+1,j,k,:), dir, [i+1, j, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_x) * (u(i,j,k,:) - u(i+1,j,k,:)))

                   drhoeLF = -TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) - TWO * (dt / alpha_x) * (area1(i+1,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   thetam_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

          enddo
       enddo
    enddo

    ! Now figure out the limiting values of theta. Each zone center has a thetap and thetam,
    ! but we want a nodal value of theta that is the strongest of the two limiters in each case.
    ! Then, limit the flux accordingly.

    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1), hi(1) + 1

             ! If an adjacent zone has a floor-violating density or energy, set the flux to zero
             ! and move on. At that point, the only thing to do is wait for a reset at a later point.

             if (u(i,j,k,URHO) < small_dens .or. u(i-1,j,k,URHO) < small_dens .or. &
                 u(i,j,k,UEINT) < small_rhoe(i,j,k) .or. u(i-1,j,k,UEINT) < small_rhoe(i-1,j,k)) then

                flux1(i,j,k,:) = ZERO
                cycle

             endif

             ! See the discussion after Equation 16 in Hu et al.; the limiting theta for both density and
             ! internal energy is a multiplicative combination of the two.

             theta = min(thetam_dens(i-1,j,k), thetap_dens(i,j,k)) * min(thetam_rhoe(i-1,j,k), thetap_rhoe(i,j,k))

             fluxL = dflux(u(i-1,j,k,:), q(i-1,j,k,:), dir, [i-1, j, k], include_pressure)
             fluxR = dflux(u(i  ,j,k,:), q(i  ,j,k,:), dir, [i  , j, k], include_pressure)
             fluxLF(:) = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_x) * (u(i-1,j,k,:) - u(i,j,k,:)))

             ! Ensure that the fluxes don't violate the floor. It is okay that we are applying
             ! these in succession multiplicatively because in each case we get a multiplicative
             ! factor on the flux, and that multiplicative factor is strictly less than one, so
             ! the (rho e) limiter will always respect preservation of positive density.

             drhoLF = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

             if (u(i,j,k,URHO) + drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
             else if (u(i-1,j,k,URHO) - drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i-1,j,k,URHO)) / drhoLF)
             endif

             drhoeLF = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

             if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
             else if (u(i-1,j,k,UEINT) - drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i-1,j,k,UEINT)) / drhoeLF)
             endif

             flux1(i,j,k,:) = (ONE - theta) * fluxLF(:) + theta * flux1(i,j,k,:)

             drho = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * flux1(i,j,k,URHO)

             if (u(i,j,k,URHO) + drho < small_dens) then
                flux1(i,j,k,:) = flux1(i,j,k,:) * abs((small_dens - u(i,j,k,URHO)) / drho)
             else if (u(i-1,j,k,URHO) - drho < small_dens) then
                flux1(i,j,k,:) = flux1(i,j,k,:) * abs((small_dens - u(i-1,j,k,URHO)) / drho)
             endif

             drhoe = TWO * (dt / alpha_x) * (area1(i,j,k) / vol(i,j,k)) * flux1(i,j,k,UEINT)

             if (u(i,j,k,UEINT) + drhoe < small_rhoe(i,j,k)) then
                flux1(i,j,k,:) = flux1(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoe)
             else if (u(i-1,j,k,UEINT) - drhoe < small_rhoe(i,j,k)) then
                flux1(i,j,k,:) = flux1(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i-1,j,k,UEINT)) / drhoe)
             endif

          enddo
       enddo
    enddo

    ! Now do the y-direction. The logic is all the same as for the x-direction,
    ! so the comments are skipped.

#if (BL_SPACEDIM >= 2)
    thetap_dens(:,:,:) = ONE
    thetam_dens(:,:,:) = ONE
    thetap_rhoe(:,:,:) = ONE
    thetam_rhoe(:,:,:) = ONE

    dir = 2

    dtdx = dt / dx(2)

    do k = lo(3), hi(3)
       do j = lo(2) - 1, hi(2) + 1
          do i = lo(1), hi(1)

             if (j .ge. lo(2)) then

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) + TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * flux2(i,j,k,URHO)

                if (rho < small_dens) then

                   fluxL = dflux(u(i,j-1,k,:), q(i,j-1,k,:), dir, [i, j-1, k], include_pressure)
                   fluxR = dflux(u(i,j  ,k,:), q(i,j  ,k,:), dir, [i, j  , k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_y) * (u(i,j-1,k,:) - u(i,j,k,:)))

                   drhoLF = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   rhoLF = u(i,j,k,URHO) + TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   thetap_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                rhoe = u(i,j,k,UEINT) + TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * flux2(i,j,k,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i,j-1,k,:), q(i,j-1,k,:), dir, [i, j-1, k], include_pressure)
                   fluxR = dflux(u(i,j  ,k,:), q(i,j  ,k,:), dir, [i, j  , k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_y) * (u(i,j-1,k,:) - u(i,j,k,:)))

                   drhoeLF = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) + TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   thetap_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

             if (j .le. hi(2)) then

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) - TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * flux2(i,j+1,k,URHO)

                if (rho < small_dens) then

                   fluxL = dflux(u(i,j  ,k,:), q(i,j  ,k,:), dir, [i, j  , k], include_pressure)
                   fluxR = dflux(u(i,j+1,k,:), q(i,j+1,k,:), dir, [i, j+1, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_y) * (u(i,j,k,:) - u(i,j+1,k,:)))

                   drhoLF = -TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   rhoLF = u(i,j,k,URHO) - TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * fluxLF(URHO)

                   thetam_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                rhoe = u(i,j,k,UEINT) - TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * flux2(i,j+1,k,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i,j  ,k,:), q(i,j  ,k,:), dir, [i, j  , k], include_pressure)
                   fluxR = dflux(u(i,j+1,k,:), q(i,j+1,k,:), dir, [i, j+1, k], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_y) * (u(i,j,k,:) - u(i,j+1,k,:)))

                   drhoeLF = -TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) - TWO * (dt / alpha_y) * (area2(i,j+1,k) / vol(i,j,k)) * fluxLF(UEINT)

                   thetam_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

          enddo
       enddo
    enddo

    do k = lo(3), hi(3)
       do j = lo(2), hi(2) + 1
          do i = lo(1), hi(1)

             if (u(i,j,k,URHO) < small_dens .or. u(i,j-1,k,URHO) < small_dens .or. &
                 u(i,j,k,UEINT) < small_rhoe(i,j,k) .or. u(i,j-1,k,UEINT) < small_rhoe(i,j-1,k)) then

                flux2(i,j,k,:) = ZERO
                cycle

             endif

             theta = min(thetam_dens(i,j-1,k), thetap_dens(i,j,k)) * min(thetam_rhoe(i,j-1,k), thetap_rhoe(i,j,k))

             fluxL = dflux(u(i,j-1,k,:), q(i,j-1,k,:), dir, [i, j-1, k], include_pressure)
             fluxR = dflux(u(i,j  ,k,:), q(i,j  ,k,:), dir, [i, j  , k], include_pressure)
             fluxLF(:) = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_y) * (u(i,j-1,k,:) - u(i,j,k,:)))

             drhoLF = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

             if (u(i,j,k,URHO) + drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
             else if (u(i,j-1,k,URHO) - drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i,j-1,k,URHO)) / drhoLF)
             endif

             drhoeLF = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

             if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
             else if (u(i,j-1,k,UEINT) - drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i,j-1,k,UEINT)) / drhoeLF)
             endif

             flux2(i,j,k,:) = (ONE - theta) * fluxLF(:) + theta * flux2(i,j,k,:)

             drho = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * flux2(i,j,k,URHO)

             if (u(i,j,k,URHO) + drho < small_dens) then
                flux2(i,j,k,:) = flux2(i,j,k,:) * abs((small_dens - u(i,j,k,URHO)) / drho)
             else if (u(i,j-1,k,URHO) - drho < small_dens) then
                flux2(i,j,k,:) = flux2(i,j,k,:) * abs((small_dens - u(i,j-1,k,URHO)) / drho)
             endif

             drhoe = TWO * (dt / alpha_y) * (area2(i,j,k) / vol(i,j,k)) * flux2(i,j,k,UEINT)

             if (u(i,j,k,UEINT) + drhoe < small_rhoe(i,j,k)) then
                flux2(i,j,k,:) = flux2(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoe)
             else if (u(i,j-1,k,UEINT) - drhoe < small_rhoe(i,j,k)) then
                flux2(i,j,k,:) = flux2(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i,j-1,k,UEINT)) / drhoe)
             endif

          enddo
       enddo
    enddo

#endif

    ! Now do the z-direction. The logic is all the same as for the x-direction,
    ! so the comments are skipped.

#if (BL_SPACEDIM == 3)
    thetap_dens(:,:,:) = ONE
    thetam_dens(:,:,:) = ONE
    thetap_rhoe(:,:,:) = ONE
    thetam_rhoe(:,:,:) = ONE

    dir = 3

    dtdx = dt / dx(3)

    do k = lo(3) - 1, hi(3) + 1
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             if (k .ge. lo(3)) then

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) + TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * flux3(i,j,k,URHO)

                if (rho < small_dens) then

                   fluxL = dflux(u(i,j,k-1,:), q(i,j,k-1,:), dir, [i, j, k-1], include_pressure)
                   fluxR = dflux(u(i,j,k  ,:), q(i,j,k  ,:), dir, [i, j, k  ], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_z) * (u(i,j,k-1,:) - u(i,j,k,:)))

                   drhoLF = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   rhoLF = u(i,j,k,URHO) + TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

                   thetap_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                rhoe = u(i,j,k,UEINT) + TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * flux3(i,j,k,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i,j,k-1,:), q(i,j,k-1,:), dir, [i, j, k-1], include_pressure)
                   fluxR = dflux(u(i,j,k  ,:), q(i,j,k  ,:), dir, [i, j, k  ], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_z) * (u(i,j,k-1,:) - u(i,j,k,:)))

                   drhoeLF = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) + TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

                   thetap_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

             if (k .le. hi(3)) then

                if (u(i,j,k,URHO) < small_dens .or. u(i,j,k,UEINT) < small_rhoe(i,j,k)) cycle

                rho = u(i,j,k,URHO) - TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * flux3(i,j,k+1,URHO)

                if (rho < small_dens) then

                   fluxL = dflux(u(i,j,k  ,:), q(i,j,k  ,:), dir, [i, j, k  ], include_pressure)
                   fluxR = dflux(u(i,j,k+1,:), q(i,j,k+1,:), dir, [i, j, k+1], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_z) * (u(i,j,k,:) - u(i,j,k+1,:)))

                   drhoLF = -TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * fluxLF(URHO)

                   if (u(i,j,k,URHO) + drhoLF < small_dens) then
                      fluxLF = fluxLF * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
                   endif

                   rhoLF = u(i,j,k,URHO) - TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * fluxLF(URHO)

                   thetam_dens(i,j,k) = (small_dens - rhoLF) / (rho - rhoLF)

                endif

                rhoe = u(i,j,k,UEINT) - TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * flux3(i,j,k+1,UEINT)

                if (rhoe < small_rhoe(i,j,k)) then

                   fluxL = dflux(u(i,j,k  ,:), q(i,j,k  ,:), dir, [i, j, k  ], include_pressure)
                   fluxR = dflux(u(i,j,k+1,:), q(i,j,k+1,:), dir, [i, j, k+1], include_pressure)
                   fluxLF = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_z) * (u(i,j,k,:) - u(i,j,k+1,:)))

                   drhoeLF = -TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * fluxLF(UEINT)

                   if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                      fluxLF = fluxLF * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
                   endif

                   rhoeLF = u(i,j,k,UEINT) - TWO * (dt / alpha_z) * (area3(i,j,k+1) / vol(i,j,k)) * fluxLF(UEINT)

                   thetam_rhoe(i,j,k) = (small_rhoe(i,j,k) - rhoeLF) / (rhoe - rhoeLF)

                endif

             endif

          enddo
       enddo
    enddo

    do k = lo(3), hi(3) + 1
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             if (u(i,j,k,URHO) < small_dens .or. u(i,j,k-1,URHO) < small_dens .or. &
                 u(i,j,k,UEINT) < small_rhoe(i,j,k) .or. u(i,j,k-1,UEINT) < small_rhoe(i,j,k-1)) then

                flux3(i,j,k,:) = ZERO
                cycle

             endif

             theta = min(thetam_dens(i,j,k-1), thetap_dens(i,j,k)) * min(thetam_rhoe(i,j,k-1), thetap_rhoe(i,j,k))

             fluxL = dflux(u(i,j,k-1,:), q(i,j,k-1,:), dir, [i, j, k-1], include_pressure)
             fluxR = dflux(u(i,j,k  ,:), q(i,j,k  ,:), dir, [i, j, k  ], include_pressure)
             fluxLF(:) = HALF * (fluxL(:) + fluxR(:) + (cfl / dtdx / alpha_z) * (u(i,j,k-1,:) - u(i,j,k,:)))

             drhoLF = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(URHO)

             if (u(i,j,k,URHO) + drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i,j,k,URHO)) / drhoLF)
             else if (u(i,j,k-1,URHO) - drhoLF < small_dens) then
                fluxLF(:) = fluxLF(:) * abs((small_dens - u(i,j,k-1,URHO)) / drhoLF)
             endif

             drhoeLF = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * fluxLF(UEINT)

             if (u(i,j,k,UEINT) + drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoeLF)
             else if (u(i,j,k-1,UEINT) - drhoeLF < small_rhoe(i,j,k)) then
                fluxLF(:) = fluxLF(:) * abs((small_rhoe(i,j,k) - u(i,j,k-1,UEINT)) / drhoeLF)
             endif

             flux3(i,j,k,:) = (ONE - theta) * fluxLF(:) + theta * flux3(i,j,k,:)

             drho = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * flux3(i,j,k,URHO)

             if (u(i,j,k,URHO) + drho < small_dens) then
                flux3(i,j,k,:) = flux3(i,j,k,:) * abs((small_dens - u(i,j,k,URHO)) / drho)
             else if (u(i,j,k-1,URHO) - drho < small_dens) then
                flux3(i,j,k,:) = flux3(i,j,k,:) * abs((small_dens - u(i,j,k-1,URHO)) / drho)
             endif

             drhoe = TWO * (dt / alpha_z) * (area3(i,j,k) / vol(i,j,k)) * flux3(i,j,k,UEINT)

             if (u(i,j,k,UEINT) + drhoe < small_rhoe(i,j,k)) then
                flux3(i,j,k,:) = flux3(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i,j,k,UEINT)) / drhoe)
             else if (u(i,j,k-1,UEINT) - drhoe < small_rhoe(i,j,k)) then
                flux3(i,j,k,:) = flux3(i,j,k,:) * abs((small_rhoe(i,j,k) - u(i,j,k-1,UEINT)) / drhoe)
             endif

          enddo
       enddo
    enddo

#endif

    call bl_deallocate(thetap_dens)
    call bl_deallocate(thetam_dens)
    call bl_deallocate(thetap_rhoe)
    call bl_deallocate(thetam_rhoe)

    call bl_deallocate(small_rhoe)

  end subroutine limit_hydro_fluxes_on_small_dens

end module advection_util_module
