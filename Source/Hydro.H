#ifndef HYDRO_H
#define HYDRO_H

#include "PeleC.H"
#include "IndexDefines.H"
#include "PelePhysics.H"
#include "Utilities.H"
#include "Godunov.H"

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
pc_srctoprim(
  const int i,
  const int j,
  const int k,
  amrex::Array4<const amrex::Real> const& q,
  amrex::Array4<const amrex::Real> const& qa,
  amrex::Array4<const amrex::Real> const& src,
  amrex::Array4<amrex::Real> const& srcq)
{
  // Local loading Vars ==> Load once from global memory use multiple times
  const amrex::Real srcrho = src(i, j, k, URHO);
  const amrex::Real rhoinv = 1.0 / q(i, j, k, QRHO);
  const amrex::Real vx = q(i, j, k, QU);
  const amrex::Real vy = q(i, j, k, QV);
  const amrex::Real vz = q(i, j, k, QW);
  const amrex::Real umx = src(i, j, k, UMX);
  const amrex::Real umy = src(i, j, k, UMY);
  const amrex::Real umz = src(i, j, k, UMZ);
  // SrcQ Calc
  srcq(i, j, k, QRHO) = srcrho;
  srcq(i, j, k, QU) = (umx - vx * srcrho) * rhoinv;
  srcq(i, j, k, QV) = (umy - vy * srcrho) * rhoinv;
  srcq(i, j, k, QW) = (umz - vz * srcrho) * rhoinv;
  srcq(i, j, k, QREINT) = src(i, j, k, UEDEN) - vx * umx - vy * umy - vz * umz +
                          srcrho * (vx * vx + vy * vy + vz * vz);
  srcq(i, j, k, QPRES) =
    qa(i, j, k, QDPDE) *
      (srcq(i, j, k, QREINT) - q(i, j, k, QREINT) * srcrho * rhoinv) * rhoinv +
    qa(i, j, k, QDPDR) * srcrho;

#if NUM_ADV > 0
  for (int n = 0; n < NUM_ADV; n++) {
    srcq(i, j, k, QFA + n) =
      (src(i, j, k, UFA + n) - q(i, j, k, QFA + n) * srcrho) * rhoinv;
  }
#endif
  for (int n = 0; n < NUM_SPECIES; n++) {
    srcq(i, j, k, QFS + n) =
      (src(i, j, k, UFS + n) - q(i, j, k, QFS + n) * srcrho) * rhoinv;
  }
#if NUM_AUX > 0
  for (int n = 0; n < NUM_AUX; n++) {
    srcq(i, j, k, QFX + n) =
      (src(i, j, k, UFX + n) - q(i, j, k, QFX + n) * srcrho) * rhoinv;
  }
#endif
#if NUM_LIN > 0
  for (int n = 0; n < NUM_LIN; n++) {
    srcq(i, j, k, QLIN + n) = src(i, j, k, ULIN + n);
  }
#endif
}

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
pc_divu(
  const int i,
  const int j,
  const int k,
  amrex::Array4<const amrex::Real> const& q,
  AMREX_D_DECL(
    const amrex::Real dx, const amrex::Real dy, const amrex::Real dz),
  amrex::Array4<amrex::Real> const& divu)
{
#if AMREX_SPACEDIM == 1
  amrex::Real ux = (q(i, j, k, QU) - q(i - 1, j, k, QU)) / dx;
#elif AMREX_SPACEDIM == 2
  amrex::Real ux = 0.5 *
                   (q(i, j, k, QU) - q(i - 1, j, k, QU) + q(i, j - 1, k, QU) -
                    q(i - 1, j - 1, k, QU)) /
                   dx;
  amrex::Real vy = 0.5 *
                   (q(i, j, k, QV) - q(i, j - 1, k, QV) + q(i - 1, j, k, QV) -
                    q(i - 1, j - 1, k, QV)) /
                   dy;
#elif AMREX_SPACEDIM == 3
  amrex::Real ux =
    0.25 *
    (q(i, j, k, QU) - q(i - 1, j, k, QU) + q(i, j, k - 1, QU) -
     q(i - 1, j, k - 1, QU) + q(i, j - 1, k, QU) - q(i - 1, j - 1, k, QU) +
     q(i, j - 1, k - 1, QU) - q(i - 1, j - 1, k - 1, QU)) /
    dx;
  amrex::Real vy =
    0.25 *
    (q(i, j, k, QV) - q(i, j - 1, k, QV) + q(i, j, k - 1, QV) -
     q(i, j - 1, k - 1, QV) + q(i - 1, j, k, QV) - q(i - 1, j - 1, k, QV) +
     q(i - 1, j, k - 1, QV) - q(i - 1, j - 1, k - 1, QV)) /
    dy;
  amrex::Real wz =
    0.25 *
    (q(i, j, k, QW) - q(i, j, k - 1, QW) + q(i - 1, j, k, QW) -
     q(i - 1, j, k - 1, QW) + q(i, j - 1, k, QW) - q(i, j - 1, k - 1, QW) +
     q(i - 1, j - 1, k, QW) - q(i - 1, j - 1, k - 1, QW)) /
    dz;
#endif
  divu(i, j, k) = AMREX_D_TERM(ux, +vy, +wz);
}

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
pc_norm_spec_flx(
  const int i, const int j, const int k, amrex::Array4<amrex::Real> const& flx)
{
  const int num = NUM_SPECIES + UFS;
  amrex::Real summ, fac;
  summ = 0.0;
  for (int n = UFS; n < num; ++n) {
    summ += flx(i, j, k, n);
  }

  fac = (summ != 0.0) ? flx(i, j, k, URHO) / summ : 1.0;
  for (int n = UFS; n < num; ++n) {
    flx(i, j, k, n) *= fac;
  }
}

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
pc_ext_flx(
  const int i,
  const int j,
  const int k,
  amrex::Array4<amrex::Real> const& flx,
  amrex::Array4<const amrex::Real> const& a)
{
  amrex::Real area = a(i, j, k); // avoid reading from global memory NVAR times
  for (int n = 0; n < NVAR; ++n) {
    flx(i, j, k, n) *= area;
  }
}

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
pc_update(
  const int i,
  const int j,
  const int k,
  amrex::Array4<amrex::Real> const& update,
  const amrex::GpuArray<const amrex::Array4<amrex::Real>, AMREX_SPACEDIM>& flx,
  amrex::Array4<const amrex::Real> const& vol,
  amrex::Array4<const amrex::Real> const& pdivu)
{
  amrex::Real v = vol(i, j, k);
  for (int n = 0; n < NVAR; ++n) {
    update(i, j, k, n) += (AMREX_D_TERM(
                            flx[0](i, j, k, n) - flx[0](i + 1, j, k, n),
                            +flx[1](i, j, k, n) - flx[1](i, j + 1, k, n),
                            +flx[2](i, j, k, n) - flx[2](i, j, k + 1, n))) /
                          v;
  }

  update(i, j, k, UEINT) -= pdivu(i, j, k);
}

// Host functions
void pc_umdrv(
  const amrex::Real time,
  amrex::Box const& bx,
  const int* domlo,
  const int* domhi,
  const int* bclo,
  const int* bchi,
  amrex::Array4<const amrex::Real> const& uin,
  amrex::Array4<amrex::Real> const& uout,
  amrex::Array4<const amrex::Real> const& q,
  amrex::Array4<const amrex::Real> const& qaux,
  amrex::Array4<const amrex::Real> const&
    src_q, // amrex::IArrayBox const& bcMask,
  const amrex::GpuArray<amrex::Real, AMREX_SPACEDIM>& dx,
  const amrex::Real dt,
  const int ppm_type,
  const bool use_flattening,
  const bool use_hybrid_weno,
  const int weno_scheme,
  const amrex::Real difmag,
  const amrex::GpuArray<const amrex::Array4<amrex::Real>, AMREX_SPACEDIM>& flx,
  const amrex::GpuArray<const amrex::Array4<const amrex::Real>, AMREX_SPACEDIM>&
    a,
  amrex::Array4<amrex::Real> const& vol,
  amrex::Real cflLoc);

void pc_umdrv_eb(
  const amrex::Box& bx,
  const amrex::Box& bxg_i,
  const amrex::MFIter& mfi,
  const amrex::Geometry& geom,
  const amrex::EBFArrayBoxFactory* fact,
  const int* bclo,
  const int* bchi,
  const amrex::Array4<const amrex::Real>& uin,
  const amrex::Array4<amrex::Real>& uout,
  const amrex::Array4<const amrex::Real>& q,
  const amrex::Array4<const amrex::Real>& qaux,
  const amrex::Array4<const amrex::Real>& src_q,
  const amrex::Array4<const amrex::Real>& vf,
  const amrex::Array4<amrex::EBCellFlag const>& flag,
  const amrex::GpuArray<amrex::Real, AMREX_SPACEDIM>& dx,
  const amrex::GpuArray<amrex::Real, AMREX_SPACEDIM>& dxInv,
  const amrex::GpuArray<const amrex::Array4<amrex::Real>, AMREX_SPACEDIM> flx,
  const int as_crse,
  const amrex::Array4<amrex::Real>& drho_as_crse,
  const amrex::Array4<int const>& rrflag_as_crse,
  const int as_fine,
  const amrex::Array4<amrex::Real>& dm_as_fine,
  const amrex::Array4<int const>& lev_mask,
  const amrex::Real dt,
  const int ppm_type,
  const int plm_iorder,
  const int use_flattening,
  const amrex::Real difmag,
  amrex::BCRec const* bcs_d_ptr,
  const std::string& redistribution_type,
  const int eb_weights_type,
  amrex::Real cflLoc);

void pc_adjust_fluxes(
  const amrex::Box& bx,
  const amrex::Array4<const amrex::Real>& u,
  const amrex::GpuArray<const amrex::Array4<amrex::Real>, AMREX_SPACEDIM>& flx,
  const amrex::GpuArray<const amrex::Array4<const amrex::Real>, AMREX_SPACEDIM>&
    a,
  const amrex::Array4<const amrex::Real>& divu,
  const amrex::GpuArray<amrex::Real, AMREX_SPACEDIM>& del,
  const amrex::Real difmag);

void pc_consup(
  const amrex::Box& bx,
  const amrex::Array4<amrex::Real>& update,
  const amrex::GpuArray<const amrex::Array4<amrex::Real>, AMREX_SPACEDIM>& flx,
  const amrex::Array4<const amrex::Real>& vol,
  const amrex::Array4<const amrex::Real>& pdivu);
#endif
